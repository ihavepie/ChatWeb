# 1、登录和注册的接口：

## 登录接口：

当前端发送登录信息过来时，会提交到这里，先判断是否存在，如果不存在返回0，如果存在返回1，如果密码错误返回2。

## Service

```java
/*
*目前这个方法在UserRepositoryImp类中，实际应该为数据库交互层的类，该方法更倾向于Service层，  之后会迁移到UserService类中，再加上对mongodb操作的封装不到位，之后会将数据库操作做进一步的封装
@用户名不存在 返回0
@登录成功 返回1
@密码错误 返回2
*/

@Override
    public int login(User user) {
        Query query=new Query(Criteria.where("username").is(user.getUsername()));
        User founduser=mongoTemplate.findOne(query,User.class);
        if (founduser==null){
            System.out.println("该用户不存在，请检查你输入的用户名");
            return 0;
        }else {
            String password=user.getPassword();
            BCryptPasswordEncoder encoder=new BCryptPasswordEncoder();
            if (encoder.matches(password,founduser.getPassword())){
                System.out.println("登录成功");
                return 1;
            }else {
                System.out.println("密码错误");
                return 2;
            }
        }
    }
```

## Controller

主要做转发http请求的功能，获取接口的地址为localhost:8080/工程名/Login

```java
@RequestMapping(value = "/Login",method = {RequestMethod.GET,RequestMethod.POST})
    public @ResponseBody Map<String,Integer> Login(@RequestBody User user,HttpServletRequest request){
        String username=user.getUsername();
        int status=userDao.login(user);
        if (status==1){
            request.getSession().setAttribute("username",username);
        }
        Map<String,Integer> response=new HashMap<>();
        response.put("status",status);
        return response;
    }
```

## 注册接口：

当前端发送注册信息过来时，会提交到这里，先判断是否注册信息是否为空，如果为空返回0，注册成功返回1，如果用户名被占用返回2。

## Service

```java
/*
*@注册信息为空 返回0
*@注册成功 返回1
*@用户名被占用 返回2
*/
@Override
    public int register(User user) {
        try {
            String username=user.getUsername();
            String password=user.getPassword();
            if (password==null || password.length() == 0 || username==null || username.length() == 0){
                System.out.println("注册信息不能为空");
                return 2;
            }else {
                BCryptPasswordEncoder encoder=new BCryptPasswordEncoder();
                String encoded=encoder.encode(password);
                user.setPassword(encoded);
                mongoTemplate.insert(user);
                System.out.println("注册成功");
                return 1;
            }
        }catch (Exception exception){
            System.out.println("该用户名已被占用");
        }
        return 0;
    }
```

## Controller

主要做转发http请求的功能，获取接口的地址为localhost:8080/工程名/Register

```java
@RequestMapping(value = "/Register",method = {RequestMethod.GET,RequestMethod.POST})
    public @ResponseBody Map<String,Integer> Register(@RequestBody User user,HttpServletRequest request){
        String username=user.getUsername();
        int status=userDao.register(user);
        if (status==1){
            request.getSession().setAttribute("username",username);
        }
        Map<String,Integer> response=new HashMap<>();
        response.put("status",status);
        return response;
    }
```

# 2、WebSocket接口

获取接口地址为localhost:8080/工程名/Chat

传输格式：

发送的格式：{"toName":"需要传给谁"，"content":"传什么内容"}，两个键值对都是字符串

接收的格式：{"isSystem":"是否是系统发送的"，"fromName":"谁发过来的"，"content":"发过来什么内容"}  isSystem是Boolean类型，fromName是字符串，content是Object，因为如果是系统传来的话content就是一个数组类型的，所以就用了Object类型，如果是系统发送的消息就没有fromName。

```java
#发送信息
public class Message {
    @SerializedName("toName")
    private String toName;
    @SerializedName("content")
    private String content;

    public String getToName() {
        return toName;
    }

    public void setToName(String toName) {
        this.toName = toName;
    }

    public String getContent() {
        return content;
    }

    public void setContent(String content) {
        this.content = content;
    }
}
```

```java
#接收信息
public class ResultMessage {
    private Boolean isSystem;
    private String fromName;
    private Object content;

    public Boolean getSystem() {
        return isSystem;
    }

    public void setSystem(Boolean system) {
        isSystem = system;
    }

    public String getFromName() {
        return fromName;
    }

    public void setFromName(String fromName) {
        this.fromName = fromName;
    }

    public Object getContent() {
        return content;
    }

    public void setContent(Object content) {
        this.content = content;
    }
}

```

WebSocket连接建立第一步调用onopen方法从之前在登录或者注册中写入的HttpSession对象中获取用户名作为键值并ChatEndpoint对象保存进缓存中（ChatEndpoint你可以理解为就是用户本身），随后向所有在缓存中的用户广播谁上线了，这个广播有一点问题现在，但也可能是我前端的问题，会将所有在缓存中的用户都广播一遍，原本应该是新进来的用户广播所有的在线用户，已经进来的用户只会通知新用户进来了，但现在是全部都再通知一遍，这个之后解决，其他的单播就没什么问题了，只要遵从传输格式就没什么问题，还有一个问题就是下线的时候会再广播一遍还在缓存中的用户，因为我是用一个浏览器来测试的会出现个问题就是后登录的用户会覆盖掉之前的用户导致程序报错，虽然不会停止程序但，某种程度上是个隐患，需要你前端去做对应的重定向工作，一个浏览器上如果有登录了就不能再登录一遍了，这是因为用了HttpSession的问题导致不能双开，所以如果你像我这样测试比较简陋的话，需要注意，如果用了两个浏览器就没什么问题了。

```java
@ServerEndpoint(value = "/Chat" ,configurator = GetHttpSessionConfigurator.class)
@Component
public class ChatEndpoint {
    private static Map<String,ChatEndpoint> onlineUsers=new ConcurrentHashMap<>();
    private Session session;
    private HttpSession httpSession;
    @OnOpen
    public void onOpen(Session session, EndpointConfig config){
        this.session=session;
        HttpSession httpSession= (HttpSession) config.getUserProperties().get(HttpSession.class.getName());
        this.httpSession=httpSession;

        String username= (String) httpSession.getAttribute("username");
        onlineUsers.put(username,this);

        String message= MessageUtil.getMessage(true,null,getNames());
        broadcastAllUsers(message);
    }
    private Set<String> getNames(){
        return onlineUsers.keySet();
    }
    private void broadcastAllUsers(String message){
        try {
        Set<String> names=onlineUsers.keySet();
        for (String name: names){
            ChatEndpoint chatEndpoint=onlineUsers.get(name);
            chatEndpoint.session.getBasicRemote().sendText(message);
        }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @OnMessage
    public void onMessage(String message, Session session) {
        try {
        Gson gson=new Gson();
        Message receive= gson.fromJson(message, Message.class);
        String toName=receive.getToName();
        String content=receive.getContent();
        String username=(String) httpSession.getAttribute("username");
        String send=MessageUtil.getMessage(false,username,content);
        onlineUsers.get(toName).session.getBasicRemote().sendText(send);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    @OnClose
    public void onClose() {
        // 处理连接关闭时的逻辑
        try {
            onlineUsers.remove((String) httpSession.getAttribute("username"));
            session.close();
            String message=MessageUtil.getMessage(true,null,getNames());
            broadcastAllUsers(message);
            System.out.println(httpSession.getAttribute("username")+"下线");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}

```

